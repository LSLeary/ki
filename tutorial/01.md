[Next tutorial](02.md)

---

# Tutorial 1

In this tutorial, we'll learn about the __scope__ abstraction, and get
comfortable using it.

```haskell
{-# LANGUAGE BlockArguments #-}
module Tutorial01 where
import qualified Ki
main = pure () :: IO ()
```

`Ki` exposes a stripped-down version of the `ki` API; we'll learn about the
functionality it _doesn't_ offer later.

We're ready to open a __scope__!

```haskell
example1 :: IO ()
example1 =
  Ki.scoped \scope ->
    putStrLn "Hello, world!"
```

Why'd we do that? Well, no good reason. We don't _need_ to open a __scope__ just
to print a message to the console, but we did anyway.

`scoped` is the entrypoint to all of the functionality that `ki` offers. Let's
look at its type.

```haskell ignore
scoped :: (Scope -> IO a) -> IO a
```

It opens a new __scope__, passes it to a callback function, and then closes
it afterwards. A closed __scope__ is useless, and attempting to use it will
throw an exception.

A __scope__ is a first-class reference to a scope in which __threads__ are
created; it delimits the lifetime of all such __threads__.

When a __scope__ "goes out of scope" (or _closes_), all remaining __threads__
are killed, and by the time `scoped` returns, they are all guaranteed to have
finished.

This is the primary advantage of using a structured concurrency library like
`ki`: it is difficult to accidentally leave a __thread__ running in the
background as a side-effect of a function call, because they _must_ be created
within a __scope__.

But I haven't shown you how to create a __thread__ yet - we'll get to that soon.
For now, let's see an example of creating a __scope__ within a __scope__.

```haskell
example2 :: IO ()
example2 = do
  Ki.scoped \scope1 -> do
    putStrLn "Hello with one scope open!"

    Ki.scoped \scope2 -> do
      putStrLn "Hello with two scopes open!"

    putStrLn "Back to one again!"
```

---

[Next tutorial](02.md)
