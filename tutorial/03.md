[Previous tutorial](02.md) | [Next tutorial](04.md)

---

# Tutorial 3

In this tutorial, we'll learn how to wait for all __threads__ created within a
__scope__ at the same time.

```haskell
{-# LANGUAGE BlockArguments #-}
module Tutorial03 where
import qualified Ki
main = pure () :: IO ()
```

Managing __threads__ individually is sometimes cumbersome: what if we wanted to
perform two actions concurrently, and wait for both of them to complete?

```haskell
example1 :: IO ()
example1 = do
  Ki.scoped \scope -> do
    thread1 <- Ki.fork scope (putStrLn "Hello from thread 1!")
    thread2 <- Ki.fork scope (putStrLn "Hello from thread 2!")
    Ki.await thread1
    Ki.await thread2
```

`ki` provides a way to block until all __threads__ created within a __scope__
finish:

```haskell ignore
wait :: Scope -> IO ()
```

Using `wait`, we can choose to toss the individual `Thread` values and treat the
entire __scope__ as a bundle:

```haskell
example2 :: IO ()
example2 = do
  Ki.scoped \scope -> do
    _ <- Ki.fork scope (putStrLn "Hello from thread 1!")
    _ <- Ki.fork scope (putStrLn "Hello from thread 2!")
    Ki.wait scope
```

There's also a `waitFor` variant, analogous to `awaitFor`.

---

[Previous tutorial](02.md) | [Next tutorial](04.md)
