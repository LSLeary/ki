[Previous tutorial](01.md)

---

# Tutorial 2

In this tutorial, we'll learn how to spawn a __thread__ within a __scope__.

Let's get our import out of the way.

```haskell
{-# LANGUAGE BlockArguments #-}
module Tutorial02 where
import qualified Ki.Lite as Ki
```

There are two variants of spawning a __thread__ within a __scope__ that have
different exception-propagation semantics. We'll explore those intricacies
later. For now, let's just play around with __threads__ that never throw
exceptions.

Enter `fork`:

```haskell ignore
fork :: Scope -> IO () -> IO ()
```

As you may have guessed, this function corresponds to a single `forkIO`; that
is, it spawns a "green thread" that the runtime system will eventually schedule
onto an available OS thread.

Its type is different from `forkIO` in a couple of important ways, however.

  * It takes a __scope__ as input, which ensures when the __scope__ /closes/,
    the __thread__ is killed.
  * It doesn't return a `ThreadId`; __threads__ in `ki` are managed at a
    slightly higher level of abstraction than individual identifiers.

Let's try it out.

```haskell
main :: IO ()
main =
  Ki.scoped \scope ->
    Ki.fork scope (putStrLn "Hello, world!")
```

If you run this, you may notice it print `"Hello, world!"`, or not. That's
because there's a race condition: remember, when the __scope__ /closes/, it
kills all remaining __threads__ and waits for them to finish.

In this case, we don't want to fall out of the callback just yet - we'd rather
wait for all of the __threads__ we spawned to finish. For that, we'll need a new
function:

```haskell ignore
wait :: Scope -> IO ()
```

`wait` will _block_ until all __threads__ within a __scope__ finish. Let's try
our hand at spawning a __thread__ one more time.

```haskell
  Ki.scoped \scope -> do
    Ki.fork scope (putStrLn "Hello, world!")
    Ki.wait scope
```

---

[Previous tutorial](01.md)
