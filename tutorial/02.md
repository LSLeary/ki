[Previous tutorial](01.md) | [Next tutorial](03.md)

---

# Tutorial 2

In this tutorial, we'll learn how to create a __thread__ within a __scope__.

```haskell
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NumericUnderscores #-}
module Tutorial02 where
import qualified Ki.Lite as Ki
main = pure () :: IO ()
```

There are two kinds of __thread__ that have different exception-propagation
semantics. We'll explore those intricacies later. For now, let's just experiment
with well-behaved __threads__ that never throw exceptions.

Enter `fork`:

```haskell ignore
fork :: Scope -> IO a -> IO (Thread a)
```

As you may have guessed, this function corresponds to a single `forkIO` call
under the hood; that is, it creates a "green thread" that the runtime system
will eventually schedule onto an available OS thread.

Its type is different from `forkIO` in a couple of important ways, however.

  * It takes a __scope__ as input, which ensures when the __scope__ closes,
    the __thread__ is killed. This is the fundamental idea behind "structured
    concurrency": no __threads__ can outlive the __scope__ in which they are
    created.
  * It takes an action that returns a value of any type.
  * It returns a parameterized `Thread` value instead of a naked `ThreadId`;
    __threads__ in `ki` are managed at a higher level of abstraction than
    individual identifiers.

Let's try it out.

```haskell
example1 :: IO ()
example1 = do
  Ki.scoped \scope -> do
    _thread <- Ki.fork scope (putStrLn "Hello, world!")
    pure ()
```

If you run this, you may notice it print `"Hello, world!"`, or not. That's
because there's a race condition: remember, when the __scope__ closes, it
kills all remaining __threads__ and waits for them to finish.

In this case, we don't want to fall out of the callback just yet - we'd rather
give our __thread__ a chance to run to completion. For that, we'll need a new
function:

```haskell ignore
await :: Thread a -> IO a
```

`await` will _block_ until the given __threads__ finishes. Let's try our hand at
creating a __thread__ one more time.

```haskell
example2 :: IO ()
example2 = do
  Ki.scoped \scope -> do
    thread <- Ki.fork scope (putStrLn "Hello, world!")
    Ki.await thread
```

This program no longer contains a race condition. It will always print
`"Hello, world!"`. Cool!

`ki` provides a variant of `await` that gives up after a given duration. This,
together with `scoped`'s teardown behavior, can be used to speculatively execute
an action that may take too long, and if it does, cancel it.

```haskell
example3 :: IO ()
example3 = do
  Ki.scoped \scope -> do
    thread <- Ki.fork scope (Ki.sleep (1 * Ki.seconds))
    Ki.awaitFor thread (0.5 * Ki.seconds) >>= \case
      Nothing -> putStrLn "Thread didn't finish! Oh well, killing it."
      Just () -> putStrLn "Thread finished!"
```

---

[Previous tutorial](01.md) | [Next tutorial](03.md)
