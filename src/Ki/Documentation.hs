module Ki.Documentation
  ( -- * Introduction
    -- $introduction

    -- * Tutorial

    -- ** Background

    -- ** Structured concurrency
    -- $tutorial-structured-concurrency

    -- ** Creating threads
    -- $tutorial-creating-threads

    -- ** Exception propagation
    -- $tutorial-exception-propagation

    -- ** Soft-cancellation
    -- $tutorial-soft-cancellation

    -- * Examples
    -- $example-has-context-anchor

    -- ** Integrating ki with your application monad
    -- $example-has-context

    -- * Reference manual
    -- $reference-manual
  )
where

-- $introduction
--
-- This package provides two variants:
--
-- * "Ki" exposes a simplified version of the full API that does not include support for soft-cancellation. Thus, none
--   of the functions mention a __context__ type, and you may use any @MonadUnliftIO@-compatible monad, including plain
--   @IO@. If you do not intend to use soft-cancellation, there is no benefit to using the full API. Start here :)
--
-- * "Ki.Implicit" and "Ki.Reader" extend "Ki" with a __context__ type that's used to propagate soft-cancellation
--   signals. Because manually threading the right __context__ throughout a program is error-prone boilerplate,
--   package offers two ways of handling it implicitly: using implicit parameters, and using a reader monad.

-- $tutorial-structured-concurrency
--
-- "Structured concurrency" is a style of concurrent programming in which threads are always created within a lexical
-- scope, and cannot outlive the scope in which they were created.
--
-- In GHC Haskell, the lifetime of a (child) thread created with 'Control.Concurrent.forkIO' is unrelated to the
-- lifetime of the (parent) thread that created it: if a child thread terminates, its parent can continue running; if a
-- parent thread terminates, its children can continue running.
--
-- Although sometimes convenient, this style of concurrent programming often leads to undesirably complex programs,
-- wherein any IO action can create a thread as a side effect, which may be left running in the background, often
-- unintentionally, after the IO action completes, throws an exception, or is thrown an asynchronous exception.
--
-- This belies the humble function abstraction: if a function may create a thread that is left running after the
-- function itself returns, then it can be considered to have multiple exit points - one additional exit point for each
-- thread it left running. This is harmful for the same reasons that Dijkstra argued the @goto@ statement is harmful. A
-- program becomes significantly easier to understand if, whenever a function is invoked, the reader can be certain that
-- no matter what the function does internally, control will return to the very next statement.

-- $tutorial-creating-threads
--
-- In @ki@, the scope in which threads are created is a first-class value. A scope can only be created by the
-- 'Ki.scoped' (cf. _implicit_ 'Ki.Implicit.scoped', _reader_ 'Ki.Reader.scoped') function, which is a "with-style" (or
-- "bracket-style") function that accepts a callback, and the scope is only valid for the duration of the callback.
--
-- A thread can be only created within a scope, because all variants of creating a thread, such as 'Ki.fork' (cf.
-- _implicit_ 'Ki.Implicit.fork', _reader_ 'Ki.Reader.fork') and 'Ki.async' (cf. _implicit_ 'Ki.Implicit.async',
-- _reader_ 'Ki.Reader.async') accept a scope as an explicit argument. Each (child) thread created within a scope is
-- said to be a sibling of the others, and is related to its siblings only implicitly via the relationship each has with
-- its parent (the thread that created the scope itself).
--
-- When the callback provided to 'Ki.scoped' returns, the scope becomes "closed", and no new threads can be created
-- within it. All living threads that were created within the scope are thrown an asynchronous exception, and
-- 'Ki.scoped' does not return until all of them have terminated. This satisfies the basic requirement of structured
-- concurrency: a thread cannot outlive the scope in which it was created.
--
-- Here's a simple example, annotated below.
--
-- @
-- __-- (1)__
-- (result1, result2) <-
--   Ki.'Ki.scoped' \\scope ->
--     __-- (2)__
--     thread1 <- Ki.'Ki.async' scope child1
--     thread2 <- Ki.'Ki.async' scope child2
--     __-- (3)__
--     result1 <- Ki.'Ki.await' thread1
--     result2 <- Ki.'Ki.await' thread2
--     pure (result1, result2)
--     __-- (4)__
-- __-- (5)__
-- @
--
-- 1. First, we open a new scope with 'Ki.scoped'. It's only "open" for the duration of the callback we provide.
-- 2. Next, we create two threads within the scope.
-- 3. Next, we wait for both threads to return with either a value or an exception.
-- 4. Finally, we reach the end of the callback. Here, the scope is "closed", and all living threads that were created
--    within it are thrown an asynchronous exception.
-- 5. Here, all threads that were created within it scope are guaranteed to have terminated.
--
-- An explicit scope is a powerful abstraction: although it is indeed an additional argument to pass around as compared
-- to simpler thread creation APIs such as 'Control.Concurrent.forkIO' and
-- @<https://hackage.haskell.org/package/async/docs/Control-Concurrent-Async.html#v:async async>@, the threads created
-- within it are all related to each other, and this relationship often be read off the page.
--
-- In the example above, we can see that that @child1@ and @child2@ are the only threads created within the scope; there
-- are no additional lifetimes to consider when attempting to understand the behavior of this program.
--
-- This would not be the case if the scope was explicitly passed down into @child1@, for example, which would bestow
-- @child1@ with the ability to create its own siblings, nor would it be the case if the scope was implicitly passed
-- around, as by a reader monad or similar.
--
-- Passing a scope value around is still an option, and is necessary for certain advanced use cases, as well as
-- implementing concurrency abstractions such as worker pools, actors, and supervisors. But be careful - wherever the
-- scope goes, so goes the ability to create threads within it!

-- $tutorial-exception-propagation
--
-- In @ki@, exception propagation is bi-directional between parent and child threads. We've already discussed one
-- circumstance in which a parent throws exceptions to its children: when the callback provided to 'Ki.scoped' returns.
-- But this is also the case if the parent terminates abnormally by throwing an exception, or if it is thrown an
-- asynchronous exception from another thread. No matter what happens to a parent thread with an open scope, the scope
-- will be closed, at which point all living child threads are terminated.
--
-- @
-- 'Ki.scoped' \\scope ->
--   __-- (1)__
-- __-- (2)__
-- @
--
-- 1. It does not matter how many threads are created within here, whether whether the callback itself throws an
--    exception, or whether the parent thread is thrown an asynchronous exception...
-- 2. ...by the time we get here, all threads created within the scope are guaranteed to have terminated.
--
-- Sometimes, a child thread may be performing an operation that is expected to sometimes fail; for this case, @ki@
-- provides 'Ki.async' (cf. _implicit_ 'Ki.Implicit.async', _reader_ 'Ki.Reader.async'), which creates a thread that
-- does not propagate any synchronous exceptions to its parent. Rather, these exceptions are made available for the
-- parent thread to 'Ki.await' (cf _implicit_ 'Ki.Implicit.await', _reader_ 'Ki.Reader.await') and handle however it
-- wishes.
--
-- Other times, it is considered very unexpected or erroneous for a child thread to fail; for this case, @ki@ provides
-- 'Ki.fork' (cf. _implicit 'Ki.Implicit.Fork', _reader_ 'Ki.Reader.fork'), which creates a thread that immediately
-- propagates any synchronous exception it throws to its parent. The intention is to facillitate "failing fast and loud"
-- when there is little or nothing sensible for the programmer to do besides propagate the exception up the call tree.
--
-- In either case, if a child thread is deliviered an asynchronous exception, it is immediately propagated to its
-- parent. This is in accordance with exception-handling best practices, which dictate that asynchronous exceptions
-- should never be ignored.
--
-- Each child thread can be thought to increases the "surface area" of the parent thread's identity, in the sense that
-- any synchronous or asynchronous exception thrown by or to a child will ultimately be re-thrown by or to the parent.

-- $tutorial-soft-cancellation
--
-- An application may want to feature a "graceful teardown" procedure, which is preferred to a hard-shutdown as induced
-- by power loss or similar. The PostgreSQL server, for example, will first flush its write-ahead log to disk before
-- terminating, if it's sent a catchable kill signal such as SIGINT.
--
-- Similarly, a Web server may want to terminate a request-handler thread that has exceeded the amount of time the
-- server is willing to dedicate to handling the request, yet it would nonetheless prefer to allow the thread to clean
-- up and terminate on its own terms, to reduce the likelihood that the application is brought to a chaotic state.
--
-- For these use cases, @ki@ provides a "soft-cancellation" mechanism (in contrast to the "hard-cancellation" mechanism
-- provided by GHC, 'Control.Concurrent.throwTo'). A soft-cancelled thread may observe that it is soft-cancelled, but it
-- is under no obligation to respect the cancellation.
--
-- Let's see an example. First, from the perspective of a parent thread that opens a scope, creates a child thread, and
-- soft-cancels the scope.
--
-- @
-- 'Ki.Reader.scoped' \\scope -> do
--   -- __(1)__
--   'Ki.Reader.fork_' scope child
--   -- __(2)__
--   'Ki.Reader.cancel' scope
--   -- __(3)__
--   'Ki.Reader.waitFor' scope (5 * 'Ki.Reader.seconds')
--   -- __(4)__
-- @
--
-- 1. First, we create a child thread.
-- 2. Next, we cancel the scope. This allows the child (and its children, and so on) created within the scope to observe
--    the soft-cancellation.
-- 3. Finally, we wait for up to 5 seconds for the child to terminate. We elect not to wait indefinitely, to account for
--    the possibility that the child thread either does not ever observe the soft-cancellation signal, or does not
--    manage to perform its teardown procedure in a timely manner.
-- 4. Here, if the child is still alive, it will be hard-cancelled as the scope closes.

-- $example-has-context-anchor
--
-- #example_has_context#

-- $example-has-context
--
-- You may have an application monad that is defined similar to the following.
--
-- @
-- data Env
--   = Env
--   { ...
--   }
--
-- newtype App a
--   = App { runApp :: Env -> IO a }
--   deriving (MonadUnliftIO) via (ReaderT Env IO)
-- @
--
-- To use this module, first add one field to your @Env@ type that holds a __context__.
--
-- @
-- data Env
--   = Env
--   { ...
--   , envContext :: 'Ki.Reader.Context'
--   , ...
--   }
-- @
--
-- Then, write a 'Ki.Reader.HasContext' instance, which is a bit of boilerplate that encapsulates how to get and set
-- this field.
--
-- @
-- instance 'Ki.Reader.HasContext' App where
--   'Ki.Reader.askContext' =
--     App \\env -> pure (envContext env)
--
--   'Ki.Reader.withContext' context action =
--     App \\env -> runApp action env{ envContext = context }
-- @
--
-- And finally, when running your monad down to @IO@ in @main@ by providing an initial environment, use
-- 'Ki.Reader.globalContext'.
--
-- @
-- main :: IO ()
-- main =
--   runApp initialEnv action
--
-- initialEnv :: Env
-- initialEnv =
--   Env
--     { ...
--     , envContext = 'Ki.Reader.globalContext'
--     , ...
--     }
--
-- action :: App ()
-- action =
--   ...
-- @

-- $reference-manual
--
-- This reference manual contains implementation details for all of the major types and functions provided by the "full"
-- variant of this library (i.e. "Ki.Implicit" or "Ki.Reader"), which includes support for soft-cancellation.
--
-- The implementation of the stripped-down "Ki" variant is the same, but all references to cancellation and contexts can
-- simply be ignored.
--
-- ==== 'Ki.Reader.asyncWithUnmask' #reference_manual_async#
--
-- 'Ki.Reader.asyncWithUnmask' creates a thread within a scope.
--
-- If the scope is closed, this function calls 'error'. Otherwise, it creates a thread with the same masking state as
-- the thread that created it, and provides the thread with an @unmask@ function, which unmasks asynchronous exceptions.
--
-- The new thread is tracked in a data structure inside the scope, keyed by a monotonically increasing integer, so that
-- when the scope is closed, all living threads can be thrown an asynchronous exception in the order they were
-- created.
--
-- When the thread terminates, if it terminated with an exception, it first determines whether or not it should
-- propagate the exception to its parent.
--
--   - If the exception is a 'Ki.Internal.ScopeClosing', it is not propagated, as it is assumed to have come from the
--     parent thread directly.
--   - If the exception is a 'Ki.Internal.CancelToken' that was observable by the thread calling 'Ki.Reader.cancelled',
--     it is not propagated, as the parent thread either initiated the cancellation directly, or else some ancestor of
--     the parent thread initiated the cancellation (in which case the parent thread could observe the same cancel token
--     with 'Ki.Reader.cancelled'); either way, the parent thread could "know about" the cancellation, so it would be
--     incorrect to propagate this exception to the parent thread and induce an immediate termination of the thread's
--     siblings.
--   - If the exception is asynchronous (e.g. a subclass of 'Control.Exception.SomeAsyncException'), it is propagated.
--   - Otherwise, the exception is not propagated.
--
-- The thread's result is then made available via 'Ki.Reader.await', and finally the thread removes itself from the data
-- structure in its scope that tracks its existence, because the purpose of the data structure is to track all threads
-- still running within a scope, so they can all be terminated when the scope closes.
